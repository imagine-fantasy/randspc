<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spend Control Builder</title>
    <style>
        :root {
            --primary-color: #3b82f6;
            --border-color: #e5e7eb;
            --text-color: #374151;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.5;
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 20px;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        .form-control {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 1rem;
        }

        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
        }

        .json-preview {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }

        .rule-section {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .condition-row,
        .control-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div id="builder-form"></div>
        </div>
        <div class="card">
            <pre id="json-output" class="json-preview"></pre>
        </div>
    </div>

    <script>
        // Core state management
        const state = {
            cardType: 'virtual',
            rules: [],
            errors: new Map()
        };

        // Constants
        const TRANSACTION_TYPES = ['purchase', 'ecommerce', 'atm', 'transfer'];
        const PERIOD_TYPES = ['hourly', 'daily', 'weekly', 'monthly', 'yearly', 'lifetime', 'cycle'];
		// Add this CSS to your styles
const tooltipStyles = `
    .tooltip-trigger {
        display: inline-flex;
        align-items: center;
        cursor: help;
        margin-left: 4px;
        font-size: 14px;
    }

    .tooltip-container {
        position: relative;
        display: inline-block;
    }

    .tooltip-content {
        visibility: hidden;
        background-color: #333;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        position: absolute;
        z-index: 100;
        width: 200px;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .tooltip-trigger:hover + .tooltip-content {
        visibility: visible;
        opacity: 1;
    }

    /* Add a little arrow at the bottom */
    .tooltip-content::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: #333 transparent transparent transparent;
    }
`;

// Add this to your CSS first
// First, add these styles to your CSS section
const velocityStyles = `
    .spending-limits {
        padding: 1rem;
        background: white;
        border-radius: 0.5rem;
    }

    .period-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem;
        border-bottom: 1px solid #e5e7eb;
    }

    .period-row:last-child {
        border-bottom: none;
    }

    .period-label {
        font-weight: 500;
        color: #374151;
        width: 150px;
    }

    .period-controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        flex: 1;
    }

    .limit-input {
        max-width: 150px;
    }

    .btn-enable {
        background: #3b82f6;
        color: white;
        padding: 0.375rem 0.75rem;
        border-radius: 0.375rem;
        font-size: 0.875rem;
    }

    .btn-remove {
        background: #ef4444;
        color: white;
        padding: 0.375rem 0.75rem;
        border-radius: 0.375rem;
        font-size: 0.875rem;
    }

    .disabled {
        opacity: 0.5;
        pointer-events: none;
    }
`;

const newStyles = `
    .error-message {
        color: #dc2626;
        font-size: 0.875rem;
        margin-top: 0.25rem;
    }

    .form-control.has-error {
        border-color: #dc2626;
    }

    .tooltip {
        position: relative;
        display: inline-block;
        margin-left: 0.5rem;
        cursor: help;
    }

    .tooltip .tooltip-text {
        visibility: hidden;
        width: 200px;
        background-color: #374151;
        color: white;
        text-align: center;
        border-radius: 6px;
        padding: 5px;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -100px;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .tooltip:hover .tooltip-text {
        visibility: visible;
        opacity: 1;
    }

    .delete-btn {
        background: #ef4444;
        color: white;
        border: none;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
    }

    .copy-btn {
        background: #10b981;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 1rem;
    }
`;

const HELP_TEXTS = {
    mcc: 'Merchant Category Codes: 4-digit codes that classify the business type',
    transactionType: 'Types like: purchase, ecommerce, atm, transfer',
    velocityLimit: 'Maximum spending allowed within the selected time period',
    singleTransaction: 'Limits for individual transactions - min cannot exceed max'
};

// Add some styles for our plain English section
const plainEnglishStyles = `
    .plain-english-section {
        margin-top: 1rem;
        padding: 1rem;
        background: #f8fafc;
        border-radius: 4px;
        border: 1px solid #e2e8f0;
    }

    .plain-english-text {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        white-space: pre-wrap;
        margin: 0;
        font-size: 0.875rem;
        line-height: 1.5;
        color: #4b5563;
    }
`;

document.querySelector('style').textContent += plainEnglishStyles;

document.querySelector('style').textContent += tooltipStyles;

        // Utility Functions
        function formatMccValue(value) {
            if (!value) return '';
            if (value.includes('-')) {
                const [start, end] = value.split('-').map(v => parseInt(v.trim()));
                if (!isNaN(start) && !isNaN(end)) {
                    return `${start}-${end}`;
                }
            }
            return value.split(',')
                .map(v => v.trim())
                .filter(v => v)
                .join(',');
        }

  // Update getDefaultRule to handle physical card rules correctly
// function getDefaultRule() {
//     return {
//         ruleName: '',
//         ruleValidityPeriod: state.cardType === 'virtual' ? {
//             ruleEffectiveDate: new Date().toISOString(),
//             ruleExpiryDate: new Date(new Date().setFullYear(new Date().getFullYear() + 1)).toISOString()
//         } : {},
//         ruleStatus: 'active',
//         ruleConditions: state.cardType === 'physical' ? undefined : undefined, // Start with undefined for physical cards
//         ruleRestriction: {
//             velocityControls: [{
//                 cumulativeAmountLimit: 0,
//                 cumulativePeriod: state.cardType === 'virtual' ? 'daily' : 'cycle'
//             }],
//             singleTransactionAmountControl: {
//                 minimumAmount: 0,
//                 maximumAmount: 1000
//             },
//             customControls: []
//         }
//     };
// }

// First, update getDefaultRule to initialize with an empty array
// Update getDefaultRule to match our new velocity controls format
function getDefaultRule() {
    return {
        ruleName: '',
        ruleValidityPeriod: {
            ruleEffectiveDate: new Date().toISOString(),
            ruleExpiryDate: new Date(new Date().setFullYear(new Date().getFullYear() + 1)).toISOString()
        },
        ruleStatus: 'active',
        ruleRestriction: {
            velocityControls: [{
                cumulativeAmountLimit: 0,
                cumulativeTransactionCountLimit: 0,
                cumulativePeriod: state.cardType === 'virtual' ? 'lifetime' : 'cycle',
                // cumulativePeriodInterval: 1
            }],
            customControls: []
            // Note: singleTransactionAmountControl is now optional and not included by default
        }
    };
}

// Update our period constants
const VIRTUAL_PERIODS = ['lifetime', 'yearly', 'monthly', 'weekly', 'daily', 'hourly', 'custom'];
const PHYSICAL_PERIODS = ['cycle', 'yearly', 'monthly', 'weekly', 'daily', 'hourly', 'custom'];


function isIntervalAllowed(period) {
    // Only these periods can have intervals
    return ['weekly','daily','hourly', 'monthly', 'yearly'].includes(period);
}

function getDefaultPeriod(cardType) {
    // Return the highest-level period for each card type
    return cardType === 'virtual' ? 'lifetime' : 'cycle';
}


function updateTimeRange(ruleIndex, controlIndex, part, value) {
    const updatedRules = [...state.rules];
    const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
    
    // Split current value or use defaults
    const [start, end] = control.controlValue ? control.controlValue.split('-') : ['00:00:00', '23:59:59'];
    
    // Update appropriate part
    if (part === 'start') {
        control.controlValue = `${value}:00-${end}`;
    } else {
        control.controlValue = `${start}-${value}:00`;
    }
    
    state.rules = updatedRules;
    render();
}

// New function to add velocity control
// 3. Core Functions for Managing Velocity Controls
// First, update where we add controls
function addVelocityControl(ruleIndex, period) {
    const updatedRules = [...state.rules];
    const rule = updatedRules[ruleIndex];
    
    const newControl = {
        cumulativeAmountLimit: 0,
        cumulativeTransactionCountLimit: 0,
        cumulativePeriod: period,
        // Only add interval if it's allowed for this period
      
    };

    // Only add interval for specific periods
    if (isIntervalAllowed(period)) {
        newControl.cumulativePeriodInterval = 1;
    }

    // For custom period, add the additional fields
    if (period === 'custom') {
        newControl.customBeginDate = new Date().toISOString();
        newControl.customDaysCount = 1;
    }

    rule.ruleRestriction.velocityControls.push(newControl);
    state.rules = updatedRules;
    render();
}


function updateVelocityControl(ruleIndex, controlIndex, field, value) {
    const updatedRules = [...state.rules];
    const control = updatedRules[ruleIndex].ruleRestriction.velocityControls[controlIndex];
    
    if (field === 'cumulativeAmountLimit' || field === 'cumulativeTransactionCountLimit') {
        control[field] = Math.max(0, parseFloat(value) || 0);
    } else {
        control[field] = value;
    }
    
    state.rules = updatedRules;
    render();


}


function deleteVelocityControl(ruleIndex, controlIndex) {
    const rule = state.rules[ruleIndex];
    const controls = rule.ruleRestriction.velocityControls;
    const periodToDelete = controls[controlIndex].cumulativePeriod;
    
    // Don't allow deleting the highest-level period
    const periods = state.cardType === 'virtual' ? VIRTUAL_PERIODS : PHYSICAL_PERIODS;
    const isHighestPeriod = !controls.some(c => 
        periods.indexOf(c.cumulativePeriod) < periods.indexOf(periodToDelete)
    );
    
    if (isHighestPeriod) {
        alert(`Cannot remove the ${formatPeriodLabel(periodToDelete)} as it's required.`);
        return;
    }
    
    const updatedRules = [...state.rules];
    updatedRules[ruleIndex].ruleRestriction.velocityControls.splice(controlIndex, 1);
    state.rules = updatedRules;
    render();
}

// Update generateVelocitySection to handle custom periods
function generateCustomPeriodControls(control, index, ruleIndex) {
    if (control.cumulativePeriod !== 'custom') return '';
    
    return `
        <div class="custom-period-controls">
            <input 
                type="datetime-local"
                class="form-control"
                value="${formatDateForInput(control.customBeginDate)}"
                onchange="updateVelocityControl(${ruleIndex}, ${index}, 'customBeginDate', this.value)"
            />
            <input 
                type="number"
                class="form-control"
                value="${control.customDaysCount || ''}"
                placeholder="Number of Days"
                min="1"
                onchange="updateVelocityControl(${ruleIndex}, ${index}, 'customDaysCount', this.value)"
            />
        </div>
    `;
}



function getNextAvailablePeriod(existingControls) {
    const periods = state.cardType === 'virtual' ? VIRTUAL_PERIODS : PHYSICAL_PERIODS;
    const usedPeriods = new Set(existingControls.map(control => control.cumulativePeriod));
    
    // Find the first period that hasn't been used yet
    return periods.find(period => !usedPeriods.has(period)) || periods[periods.length - 1];
}



// And we'll need this function to handle deletion
function deleteVelocityControl(ruleIndex, controlIndex) {
    const updatedRules = [...state.rules];
    updatedRules[ruleIndex].ruleRestriction.velocityControls.splice(controlIndex, 1);
    state.rules = updatedRules;
    render();
}


        // Template Generators
        function generateCardTypeSelector() {
            return `
                <div class="form-group">
                    <label class="form-label">Card Type</label>
                    <select class="form-control" id="card-type">
                        <option value="virtual" ${state.cardType === 'virtual' ? 'selected' : ''}>
                            Virtual (Declining Balance)
                        </option>
                        <option value="physical" ${state.cardType === 'physical' ? 'selected' : ''}>
                            Physical
                        </option>
                    </select>
                </div>
            `;
        }
		
		function generateRuleSection(rule, index) {
    return `
        <div class="rule-section" data-rule-index="${index}">
            <div class="form-group">
                <label class="form-label">Rule Name</label>
                <input 
                    type="text" 
                    class="form-control"
                    value="${rule.ruleName}"
                    onchange="updateRule(${index}, 'ruleName', this.value)"
                    placeholder="Enter rule name"
                >
            </div>
            
            ${state.cardType === 'physical' ? generateConditionsSection(rule, index) : ''}
            ${generateVelocitySection(rule, index)}
            ${generateTransactionLimitsSection(rule, index)}
            ${generateCustomControlsSection(rule, index)}
        </div>
    `;
}

// Helper function for datetime-local input
// function formatDateForInput(dateString) {
//     if (!dateString) return '';
//     return new Date(dateString).toISOString().slice(0, 16);
// }

function formatDateForInput(dateString) {
    if (!dateString) return new Date().toISOString().slice(0, 16);
    return new Date(dateString).toISOString().slice(0, 16);
}




function formatPeriodLabel(period) {
    const labels = {
        lifetime: 'Lifetime Limit',
        cycle: 'Billing Cycle',
        yearly: 'Yearly Limit',
        monthly: 'Monthly Limit',
        weekly: 'Weekly Limit',
        daily: 'Daily Limit',
        hourly: 'Hourly Limit',
        custom: 'Custom Period'
    };
    return labels[period] || period;
}




function formatPeriodLabel(period) {
    const labels = {
        lifetime: 'Lifetime Limit',
        cycle: 'Billing Cycle',
        yearly: 'Yearly Limit',
        monthly: 'Monthly Limit',
        weekly: 'Weekly Limit',
        daily: 'Daily Limit',
        hourly: 'Hourly Limit',
        custom: 'Custom Period'
    };
    return labels[period] || period;
}
function getPeriodTooltip(period) {
    const tooltips = {
        lifetime: 'Total spending limit for the entire card lifetime',
        cycle: 'Limit resets each billing cycle',
        yearly: 'Annual spending limit',
        monthly: 'Monthly spending limit',
        weekly: 'Weekly spending limit',
        daily: '24-hour rolling limit',
        hourly: 'Rolling hourly limit'
    };
    return tooltips[period] || '';
}

function canAddPeriod(controls, period) {
    const periods = state.cardType === 'virtual' ? VIRTUAL_PERIODS : PHYSICAL_PERIODS;
    const periodIndex = periods.indexOf(period);
    
    // Don't allow duplicates
    if (controls.some(c => c.cumulativePeriod === period)) {
        return false;
    }
    
    // If no controls exist, only allow the highest level period
    if (controls.length === 0) {
        return periodIndex === 0;
    }
    
    // Allow any period that comes after the existing periods in the hierarchy
    const existingIndices = controls.map(c => periods.indexOf(c.cumulativePeriod));
    const highestExistingIndex = Math.min(...existingIndices);
    return periodIndex > highestExistingIndex;
}

function generateVelocitySection(rule, index) {
    const periods = state.cardType === 'virtual' ? VIRTUAL_PERIODS : PHYSICAL_PERIODS;
    const controls = rule.ruleRestriction.velocityControls || [];

    return `
        <div class="velocity-section">
            <h3 class="form-label mb-3">Spending Limits</h3>
            <div class="grid grid-cols-2 gap-4">
                ${periods.map(period => {
                    const control = controls.find(c => c.cumulativePeriod === period);
                    const isAvailable = canAddPeriod(controls, period);
                    const showInterval = isIntervalAllowed(period); // Check if period allows intervals
                    
                    return `
                        <div class="border rounded-lg p-4 ${control ? 'border-blue-500' : ''} 
                             ${!isAvailable && !control ? 'opacity-50' : ''}">
                            <div class="flex justify-between items-center mb-4">
                                <span class="font-medium text-gray-700">
                                    ${formatPeriodLabel(period)}
                                    ${showInterval && control ? `
                                        <span class="text-sm text-gray-500">
                                            (Every ${control.cumulativePeriodInterval || 1} ${period}${control.cumulativePeriodInterval > 1 ? 's' : ''})
                                        </span>
                                    ` : ''}
                                </span>
                                ${control 
                                    ? `<button class="btn btn-danger" 
                                         onclick="deleteVelocityControl(${index}, ${controls.indexOf(control)})"
                                         ${controls.length === 1 ? 'disabled' : ''}>
                                         Remove
                                       </button>`
                                    : `<button class="btn btn-primary" 
                                         onclick="addVelocityControl(${index}, '${period}')"
                                         ${!isAvailable ? 'disabled' : ''}>
                                         Enable
                                       </button>`
                                }
                            </div>
                            
                            ${control ? `
                                <div class="space-y-3">
                                    <div>
                                        <label class="block text-sm text-gray-600 mb-1">Amount Limit ($)</label>
                                        <input 
                                            type="number"
                                            class="form-control"
                                            value="${control.cumulativeAmountLimit}"
                                            onchange="updateVelocityControl(${index}, ${controls.indexOf(control)}, 'cumulativeAmountLimit', this.value)"
                                            min="0"
                                            step="0.01"
                                        >
                                    </div>
                                    
                                    ${!(state.cardType === 'virtual' && period === 'lifetime') ? `
                                        <div>
                                            <label class="block text-sm text-gray-600 mb-1">Transaction Count</label>
                                            <input 
                                                type="number"
                                                class="form-control"
                                                value="${control.cumulativeTransactionCountLimit || ''}"
                                                onchange="updateVelocityControl(${index}, ${controls.indexOf(control)}, 'cumulativeTransactionCountLimit', this.value)"
                                                min="0"
                                                step="1"
                                            >
                                        </div>
                                    ` : ''}
                                    
                                    ${showInterval ? `
                                        <div>
                                            <label class="block text-sm text-gray-600 mb-1">
                                                Interval (How many ${period}s?)
                                                ${addSmartTooltip(`Repeat this limit every N ${period}s`)}
                                            </label>
                                            <input 
                                                type="number"
                                                class="form-control"
                                                value="${control.cumulativePeriodInterval || 1}"
                                                onchange="updateVelocityControl(${index}, ${controls.indexOf(control)}, 'cumulativePeriodInterval', this.value)"
                                                min="1"
                                                step="1"
                                            >
                                        </div>
                                    ` : ''}
                                     ${control && period === 'custom' ? `
                                                <div class="space-y-3">
                                                    <div>
                                                        <label class="block text-sm text-gray-600 mb-1">Start Date</label>
                                                        <input 
                                                            type="datetime-local"
                                                            class="form-control"
                                                            value="${formatDateForInput(control.customBeginDate)}"
                                                            onchange="updateVelocityControl(${index}, ${controls.indexOf(control)}, 'customBeginDate', this.value)"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label class="block text-sm text-gray-600 mb-1">Duration (Days)</label>
                                                        <input 
                                                            type="number"
                                                            class="form-control"
                                                            value="${control.customDaysCount || ''}"
                                                            placeholder="Enter number of days"
                                                            min="1"
                                                            onchange="updateVelocityControl(${index}, ${controls.indexOf(control)}, 'customDaysCount', this.value)"
                                                        />
                                                    </div>
                                                </div>
                                            ` : ''}
                                    
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('')}
            </div>
        </div>
    `;
}


function addCondition(ruleIndex) {
    // Check if this is the first rule - it should be a card level rule
    if (state.cardType === 'physical' && ruleIndex === 0) {
        alert('The first rule for physical cards must be a card level rule (without conditions).');
        return;
    }
    
    const updatedRules = [...state.rules];
    if (!updatedRules[ruleIndex].ruleConditions) {
        updatedRules[ruleIndex].ruleConditions = [];
    }

    // Get currently used condition types
    const usedConditionTypes = new Set(
        updatedRules[ruleIndex].ruleConditions.map(condition => condition.controlType)
    );

    // Find first available condition type
    const CONDITION_TYPES = {
        MCC: 'mcc',
        TRANSACTION_TYPE: 'transactionType',
        MERCHANT_DBA: 'merchantDba',
        COUNTRY: 'country',
        CURRENCY: 'currency',
        TERMINAL_ID: 'terminalId',
        MCCG: 'mccg',
        DAY_OF_WEEK: 'dayOfWeek',
        TIME_OF_DAY: 'timeOfDay'
    };

    const availableType = Object.values(CONDITION_TYPES)
        .find(type => !usedConditionTypes.has(type));

    if (availableType) {
        updatedRules[ruleIndex].ruleConditions.push({
            controlType: availableType,
            controlValue: '',
            valueOperator: 'equal'
        });
        state.rules = updatedRules;
        render();
    } else {
        alert('All condition types have been added. Please remove an existing condition to add a different one.');
    }
}
function generateTransactionLimitsSection(rule, index) {
    const hasLimits = !!rule.ruleRestriction.singleTransactionAmountControl;
    
    return `
        <div class="transaction-limits-section">
            <div class="section-header">
                <h3 class="form-label">
                    Single Transaction Limits
                    ${addSmartTooltip('Optional: Set min/max amounts for individual transactions')}
                </h3>
                ${!hasLimits ? `
                    <button class="btn btn-primary" onclick="enableTransactionLimits(${index})">
                        Add Limits
                    </button>
                ` : ''}
            </div>
            
            ${hasLimits ? `
                <div class="limits-container">
                    <div class="limit-group">
                        <label class="limit-label">Minimum Amount ($)</label>
                        <input 
                            type="number"
                            class="form-control"
                            value="${rule.ruleRestriction.singleTransactionAmountControl.minimumAmount || ''}"
                            placeholder="Optional"
                            onchange="updateTransactionLimit(${index}, 'minimumAmount', this.value)"
                        >
                    </div>
                    
                    <div class="limit-group">
                        <label class="limit-label">Maximum Amount ($)</label>
                        <input 
                            type="number"
                            class="form-control"
                            value="${rule.ruleRestriction.singleTransactionAmountControl.maximumAmount || ''}"
                            placeholder="Optional"
                            onchange="updateTransactionLimit(${index}, 'maximumAmount', this.value)"
                        >
                    </div>
                    
                    <button class="btn btn-danger" onclick="disableTransactionLimits(${index})">
                        Remove Limits
                    </button>
                </div>
            ` : ''}
        </div>
    `;
}

// Add these helper functions
function enableTransactionLimits(ruleIndex) {
    const updatedRules = [...state.rules];
    updatedRules[ruleIndex].ruleRestriction.singleTransactionAmountControl = {
        minimumAmount: 0,
        maximumAmount: 1000
    };
    state.rules = updatedRules;
    render();
}


// Update the generateConditionsSection to show only available types
function generateConditionsSection(rule, index) {
    // Skip for first rule of physical cards (card level rule)
    if (state.cardType === 'physical' && index === 0) {
        return '';
    }

    // Get used condition types for this rule
    const usedTypes = new Set(
        (rule.ruleConditions || []).map(condition => condition.controlType)
    );

    return `
        <div class="conditions-section">
            <div class="section-header">
                <label class="form-label">Rule Conditions (Ledger)</label>
                ${Object.keys(CONDITION_TYPES).length > usedTypes.size ? 
                    `<button class="btn btn-small" onclick="addCondition(${index})">Add Condition</button>` :
                    `<button class="btn btn-small" disabled>All Conditions Added</button>`
                }
            </div>
            ${(rule.ruleConditions || []).map((condition, condIndex) => {
                // Get available types (excluding ones already in use, except current one)
                const availableTypes = Object.entries(CONDITION_TYPES)
                    .filter(([_, value]) => 
                        value === condition.controlType || !usedTypes.has(value)
                    );

                return `
                    <div class="condition-row" data-condition-index="${condIndex}">
                        <select 
                            class="form-control"
                            onchange="updateCondition(${index}, ${condIndex}, 'controlType', this.value)"
                        >
                            ${availableTypes.map(([key, value]) => `
                                <option value="${value}" ${condition.controlType === value ? 'selected' : ''}>
                                    ${key.replace(/_/g, ' ')}
                                </option>
                            `).join('')}
                        </select>
                        ${generateControlValueInput(condition, index, condIndex)}
                        <select 
                            class="form-control"
                            onchange="updateCondition(${index}, ${condIndex}, 'valueOperator', this.value)"
                        >
                            <option value="equal" ${condition.valueOperator === 'equal' ? 'selected' : ''}>Equal</option>
                            <option value="notEqual" ${condition.valueOperator === 'notEqual' ? 'selected' : ''}>Not Equal</option>
                        </select>
                        <button 
                            class="btn-danger"
                            onclick="deleteCondition(${index}, ${condIndex})"
                        >
                            Remove
                        </button>
                    </div>
                `;
            }).join('')}
        </div>
    `;
}
function disableTransactionLimits(ruleIndex) {
    const updatedRules = [...state.rules];
    delete updatedRules[ruleIndex].ruleRestriction.singleTransactionAmountControl;
    state.rules = updatedRules;
    render();
}


// Add this function to handle updates
function updateTransactionLimit(ruleIndex, field, value) {
    const updatedRules = [...state.rules];
    const rule = updatedRules[ruleIndex];
    
    if (!rule.ruleRestriction.singleTransactionAmountControl) {
        rule.ruleRestriction.singleTransactionAmountControl = {};
    }
    
    const numValue = parseFloat(value);
    if (!isNaN(numValue)) {
        rule.ruleRestriction.singleTransactionAmountControl[field] = numValue;
        
        // Validate min/max relationship
        const { minimumAmount, maximumAmount } = rule.ruleRestriction.singleTransactionAmountControl;
        if (minimumAmount != null && maximumAmount != null && minimumAmount > maximumAmount) {
            alert('Minimum amount cannot be greater than maximum amount');
            rule.ruleRestriction.singleTransactionAmountControl[field] = 0;
        }
    }
    
    state.rules = updatedRules;
    render();
}
const CONDITION_TYPES = {
    MCC: 'mcc',
    TRANSACTION_TYPE: 'transactionType',
    MERCHANT_DBA: 'merchantDba',
    COUNTRY: 'country',
    CURRENCY: 'currency',
    TERMINAL_ID: 'terminalId',
    MCCG: 'mccg',
    DAY_OF_WEEK: 'dayOfWeek',
    TIME_OF_DAY: 'timeOfDay'
};

window.addVelocityControl = addVelocityControl;
window.updateVelocityControl = updateVelocityControl;
window.deleteVelocityControl = deleteVelocityControl;
window.updateTransactionLimit = updateTransactionLimit;
window.enableTransactionLimits = enableTransactionLimits;
window.disableTransactionLimits = disableTransactionLimits;
window.CONDITION_TYPES = CONDITION_TYPES;
window.updateControlValue = updateControlValue;
window.updateMultiSelection = updateMultiSelection;



// window.updateMultiSelection = function(ruleIndex, controlIndex, value, isChecked, type) {
//     const updatedRules = [...state.rules];
//     const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
    
//     let selectedValues = control.controlValue ? control.controlValue.split(',') : [];
    
//     if (isChecked && !selectedValues.includes(value)) {
//         selectedValues.push(value);
//     } else if (!isChecked) {
//         selectedValues = selectedValues.filter(v => v !== value);
//     }
    
//     // Sort values for consistent display
//     selectedValues.sort();
//     control.controlValue = selectedValues.join(',');
    
//     state.rules = updatedRules;
//     render();
// };

window.updateControlValue = function(ruleIndex, controlIndex, field, value) {
    console.log("UpdateControlValue called:", { ruleIndex, controlIndex, field, value }); // Debug log
    const updatedRules = [...state.rules];
    
    // First check: Is this for a rule condition?
    if (updatedRules[ruleIndex].ruleConditions?.[controlIndex]) {
        console.log("Handling rule condition update"); // Debug log
        const condition = updatedRules[ruleIndex].ruleConditions[controlIndex];
        
        // Handle different control types for rule conditions
        switch(condition.controlType) {
            case CONDITION_TYPES.MCC:
            case CONDITION_TYPES.MCCG:
                condition[field] = formatMccValue(value);
                break;
            case CONDITION_TYPES.COUNTRY:
            case CONDITION_TYPES.CURRENCY:
                condition[field] = value.toUpperCase().trim();
                break;
            default:
                condition[field] = value.trim();
        }
    }
    // Second check: Is this for a custom control?
    else if (updatedRules[ruleIndex].ruleRestriction?.customControls?.[controlIndex]) {
        console.log("Handling custom control update"); // Debug log
        const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
        
        // Handle different control types for custom controls
        switch(control.controlType) {
            case CONTROL_TYPES.MCC:
            case CONTROL_TYPES.MCCG:
                control[field] = formatMccValue(value);
                break;
            case CONTROL_TYPES.COUNTRY:
            case CONTROL_TYPES.CURRENCY:
                control[field] = value.toUpperCase().trim();
                break;
            case CONTROL_TYPES.MERCHANT_DBA:
                control[field] = value;
                break;
            case CONTROL_TYPES.TERMINAL_ID:
                control[field] = value.toUpperCase().trim();
                break;
            case CONTROL_TYPES.TIME_PERIOD:
                if (!value.includes('-')) {
                    control[field] = `${value}-23:59:59`;
                } else {
                    control[field] = value;
                }
                break;
            default:
                control[field] = value;
        }
    }
    
    state.rules = updatedRules;
    render();
};



window.updateConditionValue = function(ruleIndex, controlIndex, field, value) {
    const updatedRules = [...state.rules];
    
    if (!updatedRules[ruleIndex].ruleConditions) {
        updatedRules[ruleIndex].ruleConditions = [];
    }
    
    if (!updatedRules[ruleIndex].ruleConditions[controlIndex]) {
        updatedRules[ruleIndex].ruleConditions[controlIndex] = {
            controlType: field,
            controlValue: '',
            valueOperator: 'equal'
        };
    }
    
    const condition = updatedRules[ruleIndex].ruleConditions[controlIndex];
    condition[field] = value;
    
    state.rules = updatedRules;
    render();
};

// Then add this function definition
function updateControlValue(ruleIndex, controlIndex, field, value) {
    const updatedRules = [...state.rules];
    const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
    
    // Handle different control types appropriately
    switch(control.controlType) {
        case CONTROL_TYPES.COUNTRY:
        case CONTROL_TYPES.CURRENCY:
            // Automatically format country and currency codes to uppercase
            control[field] = value.toUpperCase().trim();
            break;
            
        case CONTROL_TYPES.MCC:
            // Clean up MCC formatting
            control[field] = value.split(',')
                .map(v => v.trim())
                .filter(v => v)
                .join(',');
            break;
        case CONTROL_TYPES.MCCG:
            // Clean up MCCG values and convert to uppercase
            control[field] = value.split(',')
                .map(v => v.trim().toUpperCase())
                .filter(v => v)
                .join(',');
            break;            
        default:
            // For all other types, just trim the value
            control[field] = value.trim();
    }
    
    state.rules = updatedRules;
    render();
}

// Then add this function definition
function updateMultiSelection(ruleIndex, controlIndex, value, isChecked, type) {
    const updatedRules = [...state.rules];
    const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
    
    // Initialize our array if it doesn't exist
    let selectedValues = control.controlValue ? control.controlValue.split(',').filter(v => v) : [];
    
    if (isChecked && !selectedValues.includes(value)) {
        selectedValues.push(value);
    } else if (!isChecked) {
        selectedValues = selectedValues.filter(v => v !== value);
    }
    
    // Keep our values tidy and well-organized
    selectedValues.sort();
    control.controlValue = selectedValues.join(',');
    
    state.rules = updatedRules;
    render();
}

window.updateTransactionTypeSelection = function(ruleIndex, controlIndex, type, isChecked) {
    const updatedRules = [...state.rules];
    
    // Ensure ruleRestriction exists
    if (!updatedRules[ruleIndex].ruleRestriction) {
        updatedRules[ruleIndex].ruleRestriction = {};
    }
    
    // Ensure customControls array exists
    if (!updatedRules[ruleIndex].ruleRestriction.customControls) {
        updatedRules[ruleIndex].ruleRestriction.customControls = [];
    }
    
    const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
    if (!control) return; // Guard clause if control doesn't exist
    
    let selectedTypes = control.controlValue ? control.controlValue.split(',') : [];
    
    if (isChecked && !selectedTypes.includes(type)) {
        selectedTypes.push(type);
    } else if (!isChecked) {
        selectedTypes = selectedTypes.filter(t => t !== type);
    }
    
    control.controlValue = selectedTypes.join(',');
    state.rules = updatedRules;
    render();
};

function updateTransactionTypeSelection(ruleIndex, controlIndex, type, isChecked) {
    const updatedRules = [...state.rules];
    
    // Ensure ruleRestriction exists
    if (!updatedRules[ruleIndex].ruleRestriction) {
        updatedRules[ruleIndex].ruleRestriction = {};
    }
    
    // Ensure customControls array exists
    if (!updatedRules[ruleIndex].ruleRestriction.customControls) {
        updatedRules[ruleIndex].ruleRestriction.customControls = [];
    }
    
    const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
    if (!control) return; // Guard clause if control doesn't exist
    
    let selectedTypes = control.controlValue ? control.controlValue.split(',') : [];
    
    if (isChecked && !selectedTypes.includes(type)) {
        selectedTypes.push(type);
    } else if (!isChecked) {
        selectedTypes = selectedTypes.filter(t => t !== type);
    }
    
    control.controlValue = selectedTypes.join(',');
    state.rules = updatedRules;
    render();
}

window.updateTransactionTypeSelection = updateTransactionTypeSelection;
// Add this for regular control value updates

window.updateTimeRange = function(ruleIndex, controlIndex, part, value) {
    const updatedRules = [...state.rules];
    // Fix: Use customControls instead of ruleConditions
    const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
    
    if (!control.controlValue) {
        control.controlValue = '00:00:00-23:59:59'; // Default value if none exists
    }
    
    const [start, end] = control.controlValue.split('-');
    
    // Ensure we keep the seconds part
    if (part === 'start') {
        control.controlValue = `${value}:00-${end}`;
    } else {
        control.controlValue = `${start}-${value}:00`;
    }
    
    state.rules = updatedRules;
    render();
};
window.updateDaySelection = function(ruleIndex, controlIndex, day, isChecked) {
    const updatedRules = [...state.rules];
    
    // Check if this is a rule condition first
    if (updatedRules[ruleIndex].ruleConditions?.[controlIndex]) {
        const condition = updatedRules[ruleIndex].ruleConditions[controlIndex];
        let days = condition.controlValue ? condition.controlValue.split(',') : [];
        
        if (isChecked && !days.includes(day)) {
            days.push(day);
        } else if (!isChecked) {
            days = days.filter(d => d !== day);
        }
        
        days.sort((a, b) => DAYS_OF_WEEK.indexOf(a) - DAYS_OF_WEEK.indexOf(b));
        condition.controlValue = days.join(',');
    }
    // Then check if it's a custom control
    else if (updatedRules[ruleIndex].ruleRestriction?.customControls?.[controlIndex]) {
        const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
        let days = control.controlValue ? control.controlValue.split(',') : [];
        
        if (isChecked && !days.includes(day)) {
            days.push(day);
        } else if (!isChecked) {
            days = days.filter(d => d !== day);
        }
        
        days.sort((a, b) => DAYS_OF_WEEK.indexOf(a) - DAYS_OF_WEEK.indexOf(b));
        control.controlValue = days.join(',');
    }
    
    state.rules = updatedRules;
    render();
};

window.updateTransactionTypeSelection = function(ruleIndex, controlIndex, type, isChecked) {
    const updatedRules = [...state.rules];
    
    // Check if this is a rule condition
    if (updatedRules[ruleIndex].ruleConditions?.[controlIndex]) {
        const condition = updatedRules[ruleIndex].ruleConditions[controlIndex];
        let selectedTypes = condition.controlValue ? condition.controlValue.split(',') : [];
        
        if (isChecked && !selectedTypes.includes(type)) {
            selectedTypes.push(type);
        } else if (!isChecked) {
            selectedTypes = selectedTypes.filter(t => t !== type);
        }
        
        condition.controlValue = selectedTypes.join(',');
    }
    // Then check if it's a custom control
    else if (updatedRules[ruleIndex].ruleRestriction?.customControls?.[controlIndex]) {
        const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
        let selectedTypes = control.controlValue ? control.controlValue.split(',') : [];
        
        if (isChecked && !selectedTypes.includes(type)) {
            selectedTypes.push(type);
        } else if (!isChecked) {
            selectedTypes = selectedTypes.filter(t => t !== type);
        }
        
        control.controlValue = selectedTypes.join(',');
    }
    
    state.rules = updatedRules;
    render();
};
function generateCustomControlsSection(rule, index) {
    const customControls = rule.ruleRestriction.customControls || [];
    const usedControlTypes = new Set(customControls.map(control => control.controlType));
    
    return `
        <div class="custom-controls-section">
            <div class="section-header">
                <label class="form-label">Authorization Rules</label>
                ${Object.keys(CONTROL_TYPES).length > usedControlTypes.size ? 
                    `<button class="btn btn-small" onclick="addCustomControl(${index})">Add Custom Control</button>` :
                    `<button class="btn btn-small" disabled>All Rules Added</button>`
                }
            </div>
            ${customControls.map((control, controlIndex) => {
                // Get available types (excluding ones already in use, except current one)
                const availableTypes = Object.entries(CONTROL_TYPES)
                    .filter(([_, value]) => 
                        value === control.controlType || !usedControlTypes.has(value)
                    );
                
                return `
                    <div class="control-row" data-control-index="${controlIndex}">
                        <select 
                            class="form-control"
                            onchange="updateCustomControl(${index}, ${controlIndex}, 'controlType', this.value)"
                        >
                            ${availableTypes.map(([key, value]) => `
                                <option value="${value}" ${control.controlType === value ? 'selected' : ''}>
                                    ${key.replace(/_/g, ' ')}
                                </option>
                            `).join('')}
                        </select>
                        ${generateControlValueInput(control, index, controlIndex)}
                        <select 
                            class="form-control"
                            onchange="updateCustomControl(${index}, ${controlIndex}, 'valueOperator', this.value)"
                        >
                            <option value="allow" ${control.valueOperator === 'allow' ? 'selected' : ''}>Allow</option>
                            <option value="disallow" ${control.valueOperator === 'disallow' ? 'selected' : ''}>Disallow</option>
                        </select>
                        <button class="btn-danger" onclick="deleteCustomControl(${index}, ${controlIndex})"></button>
                    </div>
                `;
            }).join('')}
        </div>
    `;
}

// Helper function to format control type labels nicely
function formatControlTypeLabel(controlType) {
    return CONTROL_TYPES[Object.keys(CONTROL_TYPES).find(key => 
        CONTROL_TYPES[key] === controlType
    )].replace(/_/g, ' ');
}
function generateEnhancedVelocitySection(rule, index) {
    return `
        <div class="velocity-section">
            ${Object.values(PERIOD_TYPES.TIME).map(period => `
                <div class="period-control">
                    <h4>${period.charAt(0).toUpperCase() + period.slice(1)} Limits</h4>
                    <div class="control-row">
                        <input 
                            type="number" 
                            placeholder="Amount Limit"
                            value="${rule.ruleRestriction.velocityControls.find(v => v.cumulativePeriod === period)?.cumulativeAmountLimit || ''}"
                            onchange="updateVelocityControl(${index}, '${period}', 'amount', this.value)"
                        >
                        <input 
                            type="number" 
                            placeholder="Count Limit"
                            value="${rule.ruleRestriction.velocityControls.find(v => v.cumulativePeriod === period)?.cumulativeTransactionCountLimit || ''}"
                            onchange="updateVelocityControl(${index}, '${period}', 'count', this.value)"
                        >
                    </div>
                </div>
            `).join('')}
        </div>
    `;
}
const VIRTUAL_PERIOD_TYPES = ['hourly', 'daily', 'weekly', 'monthly', 'yearly', 'lifetime'];
const PHYSICAL_PERIOD_TYPES = ['hourly', 'daily', 'weekly', 'monthly', 'yearly', 'cycle'];

const CONTROL_TYPES = {
    MCC: 'mcc',
    TRANSACTION_TYPE: 'transactionType',
    MERCHANT_DBA: 'merchantDba',
    COUNTRY: 'country',
    CURRENCY: 'currency',
    TERMINAL_ID: 'terminalId',
    MCCG: 'mccg',
    DAY_OF_WEEK: 'dayOfWeek',
    TIME_PERIOD: 'timePeriod'
};

const DAYS_OF_WEEK = ['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'];


// And for time period validation
function validateTimeFormat(time) {
    const timePattern = /^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/;
    return timePattern.test(time) ? true : 'Time must be in format HH:MM:SS between 00:00:00 and 23:59:59';
}

function updateTransactionLimits(ruleIndex, field, value) {
    const updatedRules = [...state.rules];
    updatedRules[ruleIndex].ruleRestriction.singleTransactionAmountControl[field] = parseFloat(value);
    state.rules = updatedRules;
    render();
}

function addCustomControl(ruleIndex) {
    const updatedRules = [...state.rules];
    const currentControls = updatedRules[ruleIndex].ruleRestriction.customControls || [];
    
    // Get all currently used control types
    const usedControlTypes = new Set(currentControls.map(control => control.controlType));
    
    // Find first available control type
    const availableControlType = Object.values(CONTROL_TYPES)
        .find(type => !usedControlTypes.has(type));
    
    if (availableControlType) {
        if (!updatedRules[ruleIndex].ruleRestriction.customControls) {
            updatedRules[ruleIndex].ruleRestriction.customControls = [];
        }
        
        updatedRules[ruleIndex].ruleRestriction.customControls.push({
            controlType: availableControlType,
            controlValue: '',
            valueOperator: 'allow'
        });
        
        state.rules = updatedRules;
        render();
    } else {
        alert('All control types have been added. Please remove an existing control to add a different one.');
    }
}

function updateCustomControl(ruleIndex, controlIndex, field, value) {
    const updatedRules = [...state.rules];
    updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex][field] = value;
    state.rules = updatedRules;
    render();
}

// function updateVelocity(ruleIndex, field, value) {
//     const updatedRules = [...state.rules];
//     updatedRules[ruleIndex].ruleRestriction.velocityControls[0][field] = 
//         field === 'cumulativeAmountLimit' ? parseFloat(value) : value;
//     state.rules = updatedRules;
//     render();
// }

function updateVelocityControl(ruleIndex, controlIndex, field, value) {
    const updatedRules = [...state.rules];
    if (field === 'cumulativeAmountLimit' || field === 'cumulativeTransactionCountLimit') {
        value = parseFloat(value) || 0;  // Added fallback to 0
    }
    updatedRules[ruleIndex].ruleRestriction.velocityControls[controlIndex][field] = value;
    state.rules = updatedRules;
    render();
}

// Function to delete conditions
function deleteCondition(ruleIndex, conditionIndex) {
    const updatedRules = [...state.rules];
    updatedRules[ruleIndex].ruleConditions.splice(conditionIndex, 1);
    state.rules = updatedRules;
    render();
}


function deleteCustomControl(ruleIndex, controlIndex) {
    const updatedRules = [...state.rules];
    updatedRules[ruleIndex].ruleRestriction.customControls.splice(controlIndex, 1);
    state.rules = updatedRules;
    render();
}

function addCopyButton() {
    return `
        <button class="btn" onclick="copyJsonToClipboard()">
            Copy JSON 
        </button>
    `;
}

function copyJsonToClipboard() {
    const json = JSON.stringify({ spendControlRules: state.rules }, null, 2);
    navigator.clipboard.writeText(json).then(() => {
        alert('JSON copied to clipboard!');
    });
}

function updateRule(index, field, value) {
    const updatedRules = [...state.rules];
    if (field.includes('.')) {
        // Handle nested fields
        const [parent, child] = field.split('.');
        updatedRules[index][parent][child] = value;
    } else {
        updatedRules[index][field] = value;
    }
    state.rules = updatedRules;
    render();
}

// Add these helper functions
function addTooltip(text) {
    return `
        <div class="tooltip">
            <span></span>
            <span class="tooltip-text">${text}</span>
        </div>
    `;
}

function showError(error) {
    return `<div class="error-message">${error}</div>`;
}

function getAvailableControlTypes(rule, currentIndex) {
    const usedTypes = new Set(
        rule.ruleRestriction.customControls
            .filter((_, index) => index !== currentIndex)
            .map(control => control.controlType)
    );
    
    return Object.entries(CONTROL_TYPES)
        .filter(([_, value]) => !usedTypes.has(value))
        .map(([key, value]) => ({
            label: key.replace(/_/g, ' '),
            value: value
        }));
}
// We can use these for validation later
const VALID_COUNTRIES = ['USA', 'CAN', 'GBR', 'IND', 'AUS', /* ... */];
const VALID_CURRENCIES = ['USD', 'EUR', 'GBP', 'INR', 'AUD', /* ... */];

function validateCommaList(value, validValues) {
    const inputValues = value.split(',').map(v => v.trim().toUpperCase());
    const invalidValues = inputValues.filter(v => !validValues.includes(v));
    return invalidValues.length === 0 ? true : `Invalid values: ${invalidValues.join(', ')}`;
}

function generateControlValueInput(condition, ruleIndex, controlIndex) {
    const isRuleCondition = condition.valueOperator === 'equal' || condition.valueOperator === 'notEqual';
    const updateHandler = isRuleCondition ? 'updateConditionValue' : 'updateControlValue';



    switch(condition.controlType) {
        case CONTROL_TYPES.DAY_OF_WEEK:
            const selectedDays = condition.controlValue ? condition.controlValue.split(',') : [];
            return `
                <div class="day-selector">
                    ${DAYS_OF_WEEK.map(day => `
                        <label class="day-checkbox">
                            <input 
                                type="checkbox"
                                ${selectedDays.includes(day) ? 'checked' : ''}
                                onchange="updateDaySelection(${ruleIndex}, ${controlIndex}, '${day}', this.checked)"
                            />
                            ${day}
                        </label>
                    `).join('')}
                </div>
            `;
        case CONTROL_TYPES.TERMINAL_ID:
            return `
                <input 
                    type="text"
                    class="form-control"
                    value="${condition.controlValue}"
                    placeholder="e.g., TERM123, TERM456"
                    onchange="${updateHandler}(${ruleIndex}, ${controlIndex}, 'controlValue', this.value)"
                >
                <div class="text-sm text-gray-500">Comma-separated terminal IDs</div>
            `;
        case CONTROL_TYPES.TRANSACTION_TYPE:
            const selectedTypes = condition.controlValue ? condition.controlValue.split(',') : [];
            return `
                <div class="transaction-type-selector">
                    ${TRANSACTION_TYPES.map(type => `
                        <label class="transaction-checkbox">
                            <input 
                                type="checkbox"
                                ${selectedTypes.includes(type) ? 'checked' : ''}
                                onchange="updateTransactionTypeSelection(${ruleIndex}, ${controlIndex}, '${type}', this.checked)"
                            />
                            ${type}
                        </label>
                    `).join('')}
                </div>
            `;
                
        case CONTROL_TYPES.MERCHANT_DBA:
            return `
                <input 
                    type="text"
                    class="form-control"
                    value="${condition.controlValue}"
                    placeholder="e.g., amazon, walmart"
                    onchange="${updateHandler}(${ruleIndex}, ${controlIndex}, 'controlValue', this.value)"
                >
                <div class="text-sm text-gray-500">Comma-separated merchant names</div>
            `;    

        case CONTROL_TYPES.COUNTRY:
            return `
                <input 
                    type="text"
                    class="form-control"
                    value="${condition.controlValue}"
                    placeholder="e.g., USA, CAN, GBR"
                    onchange="${updateHandler}(${ruleIndex}, ${controlIndex}, 'controlValue', this.value.toUpperCase())"
                >
                <div class="text-sm text-gray-500">Comma-separated ISO country codes</div>
            `;
        case CONTROL_TYPES.CURRENCY:
            return `
                <input 
                    type="text"
                    class="form-control"
                    value="${condition.controlValue}"
                    placeholder="e.g., USD, EUR, GBP"
                    onchange="${updateHandler}(${ruleIndex}, ${controlIndex}, 'controlValue', this.value.toUpperCase())"
                >
                <div class="text-sm text-gray-500">Comma-separated ISO currency codes</div>
            `;        
        case CONTROL_TYPES.MCC:
            return `
                <input 
                    type="text"
                    class="form-control"
                    value="${condition.controlValue}"
                    placeholder="e.g., 3000,4000,5000-6000"
                    onchange="${updateHandler}(${ruleIndex}, ${controlIndex}, 'controlValue', this.value)"
                >
            `;
        case CONTROL_TYPES.TERMINAL_ID:
            return `
                <input 
                    type="text"
                    class="form-control"
                    value="${condition.controlValue}"
                    placeholder="e.g., TERM123, TERM456"
                    onchange="${updateHandler}(${ruleIndex}, ${controlIndex}, 'controlValue', this.value)"
                >
                <div class="text-sm text-gray-500">Comma-separated terminal IDs</div>
            `;         
        case CONTROL_TYPES.TIME_PERIOD:
            const [startTime, endTime] = (condition.controlValue || '00:00:00-23:59:59').split('-');
            return `
                <div class="time-range-input">
                    <input 
                        type="time"
                        class="form-control"
                        value="${startTime.slice(0, 5)}"
                        onchange="updateTimeRange(${ruleIndex}, ${controlIndex}, 'start', this.value)"
                    />
                    <span class="mx-2">to</span>
                    <input 
                        type="time"
                        class="form-control"
                        value="${endTime.slice(0, 5)}"
                        onchange="updateTimeRange(${ruleIndex}, ${controlIndex}, 'end', this.value)"
                    />
                </div>
            `;
        case CONTROL_TYPES.MCCG:
            return `
                <input 
                    type="text"
                    class="form-control"
                    value="${condition.controlValue}"
                    placeholder="e.g., RETAIL, TRAVEL, DINING"
                    onchange="${updateHandler}(${ruleIndex}, ${controlIndex}, 'controlValue', this.value.toUpperCase())"
                >
                <div class="text-sm text-gray-500">Comma-separated MCCG codes (e.g., RETAIL,TRAVEL)</div>
            `;    
            default:
                return `
                    <input 
                        type="text"
                        class="form-control"
                        value="${condition.controlValue || ''}"
                        placeholder="${getPlaceholder(condition.controlType)}"
                        onchange="${updateHandler}(${ruleIndex}, ${controlIndex}, 'controlValue', this.value)"
                    >
                `;
    }
}

function updateDaySelection(ruleIndex, controlIndex, day, isChecked) {
    const updatedRules = [...state.rules];
    const control = updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex];
    
    // Get current days or initialize empty array
    let days = control.controlValue ? control.controlValue.split(',') : [];
    
    if (isChecked) {
        days.push(day);
    } else {
        days = days.filter(d => d !== day);
    }
    
    // Sort days in consistent order
    days.sort((a, b) => DAYS_OF_WEEK.indexOf(a) - DAYS_OF_WEEK.indexOf(b));
    
    // Update control value
    control.controlValue = days.join(',');
    state.rules = updatedRules;
    render();
}

function getPlaceholder(controlType) {
    switch(controlType) {
        case CONTROL_TYPES.MCC:
            return 'e.g., 3000,4000,5000-6000';
        case CONTROL_TYPES.MERCHANT_DBA:
            return 'Enter merchant name';
        case CONTROL_TYPES.COUNTRY:
            return 'Enter country code (e.g., US)';
        case CONTROL_TYPES.CURRENCY:
            return 'Enter currency code (e.g., USD)';
        case CONTROL_TYPES.TERMINAL_ID:
            return 'Enter terminal ID';
        case CONTROL_TYPES.MCCG:
            return 'Enter MCCG';
        default:
            return 'Enter value';
    }
}
// Update the generateRuleSection to include delete button
function generateRuleSection(rule, index) {
    const errors = validateRule(rule);
    
    return `
        <div class="rule-section" data-rule-index="${index}">
            <div class="section-header">
                <div class="form-group">
                    <label class="form-label">
                        Rule Name
                        ${addTooltip('Give your rule a descriptive name')}
                    </label>
                    <input 
                        type="text" 
                        class="form-control ${errors.some(e => e.field === 'ruleName') ? 'has-error' : ''}"
                        value="${rule.ruleName}"
                        onchange="updateRule(${index}, 'ruleName', this.value)"
                        placeholder="Enter rule name"
                    >
                    ${errors.filter(e => e.field === 'ruleName').map(e => showError(e.message)).join('')}
                </div>
                <button class="delete-btn" onclick="deleteRule(${index})">Delete Rule</button>
            </div>
            
            ${state.cardType === 'physical' ? generateConditionsSection(rule, index) : ''}
            ${generateVelocitySection(rule, index)}
            ${generateTransactionLimitsSection(rule, index)}
            ${generateCustomControlsSection(rule, index)}
        </div>
    `;
}

// Add delete functionality
function deleteRule(index) {
    const updatedRules = [...state.rules];
    updatedRules.splice(index, 1);
    state.rules = updatedRules;
    render();
}

// Add copy to clipboard functionality
document.getElementById('json-output').parentElement.insertAdjacentHTML('beforeend', `
    <button class="copy-btn" onclick="copyJsonToClipboard()">
        Copy JSON
    </button>
`);

// Add this function to your existing code
function validateRule(rule) {
    const errors = [];
    
    // Validate rule name
    if (!rule.ruleName.trim()) {
        errors.push({
            field: 'ruleName',
            message: 'Rule name is required'
        });
    }

   // Only validate transaction limits if they exist
   if (rule.ruleRestriction.singleTransactionAmountControl) {
        const { minimumAmount, maximumAmount } = rule.ruleRestriction.singleTransactionAmountControl;
        if (minimumAmount != null && maximumAmount != null && minimumAmount >= maximumAmount) {
            errors.push({
                field: 'transactionLimits',
                message: 'Minimum amount must be less than maximum amount'
            });
        }
    }
    // Validate MCC formats (only if we have conditions)
    if (rule.ruleConditions) {
        rule.ruleConditions.forEach((condition, index) => {
            if (condition.controlType === 'mcc' && condition.controlValue) {
                const mccPattern = /^(\d{4}(-\d{4})?)(,\d{4}(-\d{4})?)*$/;
                if (!mccPattern.test(condition.controlValue)) {
                    errors.push({
                        field: `condition-${index}`,
                        message: 'Invalid MCC format. Use 4-digit codes (e.g., 3000,4000 or 5000-6000)'
                    });
                }
            }
        });
    }

    return errors;
}

function validateMccInput(value) {
    // Add this to your validation helpers
    const mccValue = value.trim();
    if (!mccValue) return { isValid: true, message: '' };
    
    const patterns = {
        single: /^\d{4}$/,
        range: /^\d{4}-\d{4}$/,
        multiple: /^(\d{4})(,\d{4})*$/,
        multipleWithRanges: /^(\d{4}(-\d{4})?)(,\d{4}(-\d{4})?)*$/
    };

    if (patterns.multipleWithRanges.test(mccValue)) {
        return { isValid: true, message: ' Valid MCC format' };
    }

    let helpMessage = 'Try: 3000 or 3000-4000 or 3000,4000';
    return { isValid: false, message: ` ${helpMessage}` };
}



function getPlainEnglishDescription(rule) {
    let description = [];
    
    // Rule Header with validity period
    description.push(` ${rule.ruleName || 'Unnamed Rule'}:`);
    description.push(`Active from ${new Date(rule.ruleValidityPeriod.ruleEffectiveDate).toLocaleDateString()} to ${new Date(rule.ruleValidityPeriod.ruleExpiryDate).toLocaleDateString()}\n`);
    
    // Describe Velocity Controls
    if (rule.ruleRestriction.velocityControls?.length) {
        description.push(' Spending Limits:');
        rule.ruleRestriction.velocityControls.forEach(control => {
            let limitDesc = [];
            
            // Amount limit
            if (control.cumulativeAmountLimit) {
                limitDesc.push(`$${control.cumulativeAmountLimit.toLocaleString()}`);
            }
            
            // Transaction count
            if (control.cumulativeTransactionCountLimit) {
                limitDesc.push(`${control.cumulativeTransactionCountLimit} transactions`);
            }
            
            // Period and interval
            let periodDesc = control.cumulativePeriod;
            if (control.cumulativePeriodInterval && control.cumulativePeriodInterval > 1) {
                periodDesc = `every ${control.cumulativePeriodInterval} ${control.cumulativePeriod}s`;
            }
            
            // Custom period description
            if (control.cumulativePeriod === 'custom') {
                periodDesc = `for ${control.customDaysCount} days starting ${new Date(control.customBeginDate).toLocaleDateString()}`;
            }
            
            description.push(`   ${limitDesc.join(' and ')} per ${periodDesc}`);
        });
        description.push('');
    }
    
    // Single Transaction Limits
    if (rule.ruleRestriction.singleTransactionAmountControl) {
        const { minimumAmount, maximumAmount } = rule.ruleRestriction.singleTransactionAmountControl;
        description.push(' Single Transaction Limits:');
        description.push(`   Each transaction must be between $${minimumAmount.toLocaleString()} and $${maximumAmount.toLocaleString()}`);
        description.push('');
    }
    
    // Rule Conditions (for physical cards)
    if (rule.ruleConditions?.length) {
        description.push(' These rules apply when:');
        rule.ruleConditions.forEach(condition => {
            let conditionText = '';
            switch(condition.controlType) {
                case 'mcc':
                    conditionText = `Merchant category is ${condition.valueOperator === 'equal' ? '' : 'not'} in [${condition.controlValue}]`;
                    break;
                case 'transactionType':
                    conditionText = `Transaction type is ${condition.valueOperator === 'equal' ? '' : 'not'} ${condition.controlValue}`;
                    break;
                case 'merchantDba':
                    conditionText = `Merchant name ${condition.valueOperator === 'equal' ? 'matches' : 'does not match'} "${condition.controlValue}"`;
                    break;
                case 'country':
                    conditionText = `Transaction occurs ${condition.valueOperator === 'equal' ? 'in' : 'outside'} ${condition.controlValue}`;
                    break;
                case 'currency':
                    conditionText = `Transaction currency is ${condition.valueOperator === 'equal' ? '' : 'not'} ${condition.controlValue}`;
                    break;
                case 'dayOfWeek':
                    conditionText = `Day is ${condition.valueOperator === 'equal' ? '' : 'not'} on ${condition.controlValue}`;
                    break;
                case 'timeOfDay':
                    const [start, end] = condition.controlValue.split('-');
                    conditionText = `Time is ${condition.valueOperator === 'equal' ? '' : 'not'} between ${start} and ${end}`;
                    break;
            }
            description.push(`   ${conditionText}`);
        });
        description.push('');
    }
    
    // Custom Authorization Controls
    if (rule.ruleRestriction.customControls?.length) {
        description.push(' Authorization Rules:');
        rule.ruleRestriction.customControls.forEach(control => {
            let controlText = '';
            const action = control.valueOperator === 'allow' ? ' Allow' : ' Block';
            
            switch(control.controlType) {
                case 'mcc':
                    controlText = `merchant categories: ${control.controlValue}`;
                    break;
                case 'transactionType':
                    controlText = `${control.controlValue} transactions`;
                    break;
                case 'merchantDba':
                    controlText = `merchants: ${control.controlValue}`;
                    break;
                case 'country':
                    controlText = `transactions in ${control.controlValue}`;
                    break;
                case 'currency':
                    controlText = `transactions in ${control.controlValue}`;
                    break;
                case 'dayOfWeek':
                    controlText = `transactions on ${control.controlValue}`;
                    break;
                case 'timeOfDay':
                    const [start, end] = control.controlValue.split('-');
                    controlText = `transactions between ${start} and ${end}`;
                    break;
            }
            description.push(`   ${action} ${controlText}`);
        });
    }
    
    return description.join('\n');
}

function updateTransactionLimits(ruleIndex, field, value) {
    const updatedRules = [...state.rules];
    updatedRules[ruleIndex].ruleRestriction.singleTransactionAmountControl[field] = parseFloat(value);
    state.rules = updatedRules;
    render();
}



function updateCustomControl(ruleIndex, controlIndex, field, value) {
    const updatedRules = [...state.rules];
    updatedRules[ruleIndex].ruleRestriction.customControls[controlIndex][field] = value;
    state.rules = updatedRules;
    render();
}





// Then update our tooltip function
function addSmartTooltip(field) {
    return `
        <div class="tooltip-container">
            <span class="tooltip-trigger"></span>
            <div class="tooltip-content">
                ${HELP_TEXTS[field] || 'Help text coming soon!'}
            </div>
        </div>
    `;
}

function copyJsonToClipboard() {
    const json = JSON.stringify({ spendControlRules: state.rules }, null, 2);
    navigator.clipboard.writeText(json).then(() => {
        alert('JSON copied to clipboard!');
    });
}

function updateCondition(ruleIndex, conditionIndex, field, value) {
    const updatedRules = [...state.rules];
    
    // If we're updating the control value, format it based on the control type
    if (field === 'controlValue') {
        const controlType = updatedRules[ruleIndex].ruleConditions[conditionIndex].controlType;
        
        switch(controlType) {
            case 'mcc':
                // Handle MCC format (e.g., "3000,4000" or "3000-4000")
                value = value.split(',')
                    .map(v => v.trim())
                    .filter(v => v)
                    .join(',');
                break;
            
            case 'country':
            case 'currency':
            case 'mccg':
                // Always uppercase for these fields
                value = value.toUpperCase().trim();
                break;
            
            case 'dayOfWeek':
                // Ensure proper day format
                value = value.split(',')
                    .map(v => v.trim().toUpperCase())
                    .filter(v => DAYS_OF_WEEK.includes(v))
                    .join(',');
                break;
            
            case 'timeOfDay':
                // Ensure proper time format (HH:MM:SS-HH:MM:SS)
                if (!value.includes('-')) {
                    const [time] = value.split('-');
                    value = time ? `${time}-23:59:59` : '00:00:00-23:59:59';
                }
                // Add seconds if not provided
                value = value.split('-')
                    .map(t => t.includes(':') ? 
                        (t.split(':').length === 2 ? `${t}:00` : t) : 
                        `${t}:00:00`)
                    .join('-');
                break;
            
            case 'transactionType':
                // Ensure proper transaction type format
                value = value.split(',')
                    .map(v => v.trim().toLowerCase())
                    .filter(v => TRANSACTION_TYPES.includes(v))
                    .join(',');
                break;
                
            case 'merchantDba':
            case 'terminalId':
                // Simple trim for these fields
                value = value.trim();
                break;
        }
    }

    // Update the value in the state
    updatedRules[ruleIndex].ruleConditions[conditionIndex][field] = value;
    state.rules = updatedRules;
    render();
}
        // Event Handlers
        function addRule() {
    if (state.cardType === 'virtual' && state.rules.length > 0) return;
    
    if (state.cardType === 'physical') {
        // Check if we're adding the first rule (card level rule)
        if (state.rules.length === 0) {
            // First rule must be a card level rule (no conditions)
            const newRule = getDefaultRule();
            state.rules = [...state.rules, newRule];
        } else {
            // Check if we already have a card level rule before allowing a rule with conditions
            const hasCardLevelRule = state.rules.some(rule => !rule.ruleConditions || rule.ruleConditions.length === 0);
            if (hasCardLevelRule) {
                // Now we can add a rule with conditions
                const newRule = getDefaultRule();
                newRule.ruleConditions = []; // Initialize empty conditions array for physical card
                state.rules = [...state.rules, newRule];
            } else {
                alert('You must add a card level rule (without conditions) before adding rules with conditions.');
                return;
            }
        }
    } else {
        // Virtual card logic remains the same
        state.rules = [...state.rules, getDefaultRule()];
    }
    render();
}

        // Main render function
       // Update the render function to include both JSON and plain English
// function render() {
//     const builderForm = document.getElementById('builder-form');
    
//     const formContent = `
//         ${generateCardTypeSelector()}
//         ${state.rules.map((rule, index) => `
//             <div class="rule-section" data-rule-index="${index}">
//                 ${generateRuleSection(rule, index)}
//             </div>
//         `).join('')}
//         ${(state.cardType === 'virtual' ? state.rules.length === 0 : true) 
//             ? '<button class="btn" onclick="addRule()">Add Rule</button>' 
//             : ''
//         }
//     `;
    
//     builderForm.innerHTML = formContent;
    
//     // Update JSON preview
//     const jsonOutput = document.getElementById('json-output');
//     jsonOutput.textContent = JSON.stringify({ spendControlRules: state.rules }, null, 2);
    
//     // Log current state for debugging
//     console.log('Current state:', state);
// }

function render() {
    const builderForm = document.getElementById('builder-form');
    
    const formContent = `
        ${generateCardTypeSelector()}
        ${state.rules.map((rule, index) => `
            <div class="rule-section" data-rule-index="${index}">
                ${generateRuleSection(rule, index)}
            </div>
        `).join('')}
        ${(state.cardType === 'virtual' ? state.rules.length === 0 : true) 
            ? '<button class="btn" onclick="addRule()">Add Rule</button>' 
            : ''
        }
    `;
    
    builderForm.innerHTML = formContent;
    
    // Update JSON preview and add plain English description
    const jsonOutput = document.getElementById('json-output');
    const plainEnglishContent = state.rules.length > 0 ? `
        <div class="plain-english-section">
            <h3 style="color: #374151; margin-bottom: 1rem;"> In Plain English:</h3>
            <pre class="plain-english-text">
${state.rules.map((rule, index) => `${index + 1}. ${getPlainEnglishDescription(rule)}`).join('\n\n---\n\n')}
            </pre>
        </div>
    ` : '';
    
    // Combine JSON and plain English in the output area
    jsonOutput.parentElement.innerHTML = `
        <h3 style="color: #374151; margin-bottom: 1rem;"> Technical Details:</h3>
        <pre id="json-output" class="json-preview">${JSON.stringify({ spendControlRules: state.rules }, null, 2)}</pre>
        ${plainEnglishContent}
        <button class="copy-btn" onclick="copyJsonToClipboard()">Copy JSON </button>
    `;
    
    // Log current state for debugging
    console.log('Current state:', state);
}





        // Initialize the application
        render();

        // Event listeners
        document.getElementById('builder-form').addEventListener('change', (e) => {
            if (e.target.id === 'card-type') {
                state.cardType = e.target.value;
                state.rules = []; // Reset rules when changing card type
                render();
            }
        });
    </script>
</body>
</html>